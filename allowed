local ALLOWED_HWIDS = {
    ["HWID_ABCD1234"] = true
}

-- Функция получения HWID (аппаратный ID)
local function GetRealHWID()
    -- 1. Попытка через Synapse X/Cheat Engine
    if syn and syn.get_hwid then
        return "HWID_" .. syn.get_hwid():upper():match("%X+")
    end

    -- 2. Попытка через другие Lua-инжекторы
    if get_hwid and type(get_hwid) == "function" then
        return "HWID_" .. get_hwid():upper():match("%X+")
    end

    -- 3. Через системные команды (Windows)
    local handle = io.popen("wmic csproduct get uuid 2>nul")
    if handle then
        local result = handle:read("*a")
        handle:close()
        local hwid = result:match("UUID%s+(%x+-%x+-%x+-%x+-%x+)")
        if hwid then
            return "HWID_" .. hwid:gsub("-", ""):upper()
        end
    end

    -- 4. Через BIOS (альтернатива)
    handle = io.popen("wmic bios get serialnumber 2>nul")
    if handle then
        local result = handle:read("*a")
        handle:close()
        local serial = result:match("SerialNumber%s+(%w+)")
        if serial and serial ~= nil then
            return "HWID_" .. serial:upper()
        end
    end

    return "HWID_UNKNOWN"
end

-- Проверка и строгий выход
local function StrictHWIDCheck()
    local my_hwid = GetRealHWID()
    print("[HWID] Ваш идентификатор: " .. my_hwid)

    if not ALLOWED_HWIDS[my_hwid] then
        print("[HWID] ОШИБКА: Доступ запрещен!")
        
        -- 1. Завершение процесса (жесткий метод)
        os.execute("taskkill /f /im " .. arg[0]:match("[^\\]+$")) -- Windows
        os.exit(1)

        -- 2. Альтернатива: бесконечный цикл чтобы "заморозить" программу
        while true do end
    else
        print("[HWID] Доступ разрешен!")
    end
end

-- Запуск проверки при старте
StrictHWIDCheck()
